var documenterSearchIndex = {"docs":
[{"location":"#ParticleDA.jl","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"","category":"section"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"ParticleDA.jl is a Julia package to perform data assimilation with particle filters, distributed using MPI.","category":"page"},{"location":"#Installation","page":"ParticleDA.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"To install the package, open Julia's REPL,  enter the package manager with ], then run the command","category":"page"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"add https://github.com/Team-RADDISH/ParticleDA.jl.git","category":"page"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"If you plan to develop the package (make changes, submit pull requests, etc), in the package manager mode run this command","category":"page"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"dev https://github.com/Team-RADDISH/ParticleDA.jl.git","category":"page"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"This will automatically clone the repository to your local directory ~/.julia/dev/ParticleDA.","category":"page"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"You can exit from the package manager mode by pressing CTRL + C or, alternatively, the backspace key when there is no input in the prompt.","category":"page"},{"location":"#Usage","page":"ParticleDA.jl","title":"Usage","text":"","category":"section"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"After installing the package, you can start using it in Julia's REPL with","category":"page"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"using ParticleDA","category":"page"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"The run the particle filter you can use the function run_particle_filter:","category":"page"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"run_particle_filter","category":"page"},{"location":"#ParticleDA.run_particle_filter","page":"ParticleDA.jl","title":"ParticleDA.run_particle_filter","text":"run_particle_filter(\n    init_model,\n    input_file_path,\n    observation_file_path,\n    filter_type=BootstrapFilter,\n    summary_stat_type=MeanAndVarSummaryStat;\n    rng=Random.TaskLocalRNG()\n) -> Tuple{Matrix, Union{NamedTuple, Nothing}}\n\nRun particle filter. init_model is the function which initialise the model, input_file_path is the path to the YAML file with the input parameters. observation_file_path is the path to the HDF5 file containing the observation sequence to perform filtering for. filter_type is the particle filter type to use.   See ParticleFilter for the possible values. summary_stat_type is a type  specifying the summary statistics of the particles to compute at each time step. See  AbstractSummaryStat for the possible values. rng is a random number generator to use to generate random variates while filtering - a seeded random  number generator may be specified to ensure reproducible results. If running with multiple threads a thread-safe generator such as Random.TaskLocalRNG (the default) must be used.\n\nReturns a tuple containing the state particles representing an estimate of the filtering distribution at the final observation time (with each particle a column of the returned matrix) and a named tuple containing the estimated summary statistics of this final  filtering distribution. If running on multiple ranks using MPI, the returned states array will correspond only to the particles local to this rank and the summary statistics will be returned only on the master rank with all other ranks returning nothing for their second return value.\n\n\n\n\n\n","category":"function"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"To simulate observations from the model (which can be used to for example test the filtering algorithms) you can use the function simulate_observations_from_model","category":"page"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"simulate_observations_from_model","category":"page"},{"location":"#ParticleDA.simulate_observations_from_model","page":"ParticleDA.jl","title":"ParticleDA.simulate_observations_from_model","text":"simulate_observations_from_model(\n    init_model, input_file_path, output_file_path; rng=Random.TaskLocalRNG()\n) -> Matrix\n\nSimulate observations from the state space model initialised by the init_model function with parameters specified by the model key in the input YAML file at  input_file_path and save the simulated observation and state sequences to a HDF5 file at output_file_path. rng is a random number generator to use to generate random variates while simulating from the model - a seeded random number generator may be specified to ensure reproducible results.\n\nThe input YAML file at input_file_path should have a simulate_observations key with value a dictionary with keys seed and n_time_step corresponding to respectively the number of time steps to generate observations for from the model and the seed to use to initialise the state of the random number generator used to simulate the observations.\n\nThe simulated observation sequence is returned as a matrix with columns corresponding to the observation vectors at each time step.\n\n\n\n\n\n","category":"function"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"The filter_type argument to run_particle_filter should be a concrete subtype of the ParticleFilter abstract type.","category":"page"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"ParticleDA.ParticleFilter\nBootstrapFilter\nOptimalFilter","category":"page"},{"location":"#ParticleDA.ParticleFilter","page":"ParticleDA.jl","title":"ParticleDA.ParticleFilter","text":"ParticleFilter\n\nAbstract type for particle filters.  Currently implemented subtypes are:\n\nBootstrapFilter\nOptimalFilter\n\n\n\n\n\n","category":"type"},{"location":"#ParticleDA.BootstrapFilter","page":"ParticleDA.jl","title":"ParticleDA.BootstrapFilter","text":"BootstrapFilter <: ParticleFilter\n\nSingleton type BootstrapFilter.  This can be used as argument of  run_particle_filter to select the bootstrap filter.\n\n\n\n\n\n","category":"type"},{"location":"#ParticleDA.OptimalFilter","page":"ParticleDA.jl","title":"ParticleDA.OptimalFilter","text":"OptimalFilter <: ParticleFilter\n\nSingleton type OptimalFilter.  This can be used as argument of  run_particle_filter to select the optimal proposal filter (for conditionally linear-Gaussian models).\n\n\n\n\n\n","category":"type"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"The summary_stat_type argument to run_particle_filter should be a concrete subtype of the AbstractSummaryStat abstract type.","category":"page"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"ParticleDA.AbstractSummaryStat\nParticleDA.AbstractCustomReductionSummaryStat\nParticleDA.AbstractSumReductionSummaryStat\nParticleDA.MeanAndVarSummaryStat\nParticleDA.MeanSummaryStat\nParticleDA.NaiveMeanAndVarSummaryStat\nParticleDA.NaiveMeanSummaryStat","category":"page"},{"location":"#ParticleDA.AbstractSummaryStat","page":"ParticleDA.jl","title":"ParticleDA.AbstractSummaryStat","text":"AbstractSummaryStat\n\nAbstract type for summary statistics of particle ensemble. Concrete subtypes can be passed as the filter_type argument to run_particle_filter to specify which summary statistics to record and how they are computed.\n\nSee also: AbstractSumReductionSummaryStat,  AbstractCustomReductionSummaryStat.\n\n\n\n\n\n","category":"type"},{"location":"#ParticleDA.AbstractCustomReductionSummaryStat","page":"ParticleDA.jl","title":"ParticleDA.AbstractCustomReductionSummaryStat","text":"AbstractCustomReductionSummaryStat <: AbstractSummaryStat\n\nAbstract type for summary statistics computed using custom MPI reductions. Allows greater flexibility in computing statistics which can support more numerically stable implementations, but at a cost of not being compatible with all CPU architectures. In particular, MPI.jl does not currently support custom operators  on Power PC and ARM architecures.\n\n\n\n\n\n","category":"type"},{"location":"#ParticleDA.AbstractSumReductionSummaryStat","page":"ParticleDA.jl","title":"ParticleDA.AbstractSumReductionSummaryStat","text":"AbstractSumReductionSummaryStat <: AbstractSummaryStat\n\nAbstract type for summary statistics computed using standard MPI sum reductions.  Compatible with a wider range of CPU architectures but may require less numerically stable implementations.\n\n\n\n\n\n","category":"type"},{"location":"#ParticleDA.MeanAndVarSummaryStat","page":"ParticleDA.jl","title":"ParticleDA.MeanAndVarSummaryStat","text":"MeanAndVarSummaryStat <: AbstractCustomReductionSummaryStat\n\nCustom reduction based summary statistic type which computes the means and variances o the particle ensemble for each state dimension. On CPU architectures which do not support custom reductions NaiveMeanAndVarSummaryStat can be used instead.\n\n\n\n\n\n","category":"type"},{"location":"#ParticleDA.MeanSummaryStat","page":"ParticleDA.jl","title":"ParticleDA.MeanSummaryStat","text":"MeanSummaryStat <: AbstractCustomReductionSummaryStat\n\nCustom reduction based summary statistic type which computes the means of the particle ensemble for each state dimension. On CPU architectures which do not support custom reductions NaiveMeanSummaryStat can be used instead.\n\n\n\n\n\n","category":"type"},{"location":"#ParticleDA.NaiveMeanAndVarSummaryStat","page":"ParticleDA.jl","title":"ParticleDA.NaiveMeanAndVarSummaryStat","text":"NaiveMeanAndVarSummaryStat <: AbstractSumReductionSummaryStat\n\nSum reduction based summary statistic type which computes the means and variances of the particle ensemble for each state dimension. The mean and variance are computed by directly accumulating the  sums of the particle values, the squared particle values and number of particles on each rank, with the variance computed as the scaled difference between the sum of the squares and square of the sums. This 'naive' implementation avoids custom MPI reductions but can be numerically unstable for large ensembles or state components with large values. If custom reductions are supported by the CPU architecture in use the more numerically stable MeanAndVarSummaryStat should be used instead.\n\n\n\n\n\n","category":"type"},{"location":"#ParticleDA.NaiveMeanSummaryStat","page":"ParticleDA.jl","title":"ParticleDA.NaiveMeanSummaryStat","text":"NaiveMeanSummaryStat <: AbstractSumReductionSummaryStat\n\nSum reduction based summary statistic type which computes the means of the particle ensemble for each state dimension. The mean is computed by directly accumulating the  sums of the particle values and number of particles on each rank. If custom reductions  are supported by the CPU architecture in use the more numerically stable  MeanSummaryStat should be used instead.\n\n\n\n\n\n","category":"type"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"The next section details how to write the interface between the model and the particle filter.","category":"page"},{"location":"#Interfacing-the-model","page":"ParticleDA.jl","title":"Interfacing the model","text":"","category":"section"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"The model needs to define a custom data structure and a few functions, that will be used by run_particle_filter:","category":"page"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"a custom structure which holds the data about the model.  This will be used to dispatch the methods to be defined, listed below;\nan initialisation function with the following signature:\ninit(params_dict::Dict) -> model\nwith params_dict a dictionary with the parameters of the model. This initialisation  function should create an instance of the model data structure and return it.\nThe model needs to extend the following methods, using the model type for dispatch:","category":"page"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"ParticleDA.get_state_dimension\nParticleDA.get_observation_dimension\nParticleDA.get_state_eltype\nParticleDA.get_observation_eltype\nParticleDA.sample_initial_state!\nParticleDA.update_state_deterministic!\nParticleDA.update_state_stochastic!\nParticleDA.sample_observation_given_state!\nParticleDA.get_log_density_observation_given_state\nParticleDA.write_model_metadata","category":"page"},{"location":"#ParticleDA.get_state_dimension","page":"ParticleDA.jl","title":"ParticleDA.get_state_dimension","text":"ParticleDA.get_state_dimension(model) -> Integer\n\nReturn the positive integer dimension of the state vector which is assumed to be fixed for all time steps.\n\nThis method is intended to be extended by the user with the above signature, specifying the type of model.\n\n\n\n\n\n","category":"function"},{"location":"#ParticleDA.get_observation_dimension","page":"ParticleDA.jl","title":"ParticleDA.get_observation_dimension","text":"ParticleDA.get_observation_dimension(model) -> Integer\n\nReturn the positive integer dimension of the observation vector which is assumed to be fixed for all time steps.\n\nThis method is intended to be extended by the user with the above signature, specifying the type of model.\n\n\n\n\n\n","category":"function"},{"location":"#ParticleDA.get_state_eltype","page":"ParticleDA.jl","title":"ParticleDA.get_state_eltype","text":"ParticleDA.get_state_eltype(model) -> Type\n\nReturn the element type of the state vector which is assumed to be fixed for all time steps.\n\nThis method is intended to be extended by the user with the above signature, specifying the type of model.\n\n\n\n\n\n","category":"function"},{"location":"#ParticleDA.get_observation_eltype","page":"ParticleDA.jl","title":"ParticleDA.get_observation_eltype","text":"ParticleDA.get_observation_eltype(model) -> Type\n\nReturn the element type of the observation vector which is assumed to be fixed for all time steps.\n\nThis method is intended to be extended by the user with the above signature, specifying the type of model.\n\n\n\n\n\n","category":"function"},{"location":"#ParticleDA.sample_initial_state!","page":"ParticleDA.jl","title":"ParticleDA.sample_initial_state!","text":"ParticleDA.sample_initial_state!(state, model, rng)\n\nSample value for state vector from its initial distribution for model described by  model using random number generator rng to generate random draws and writing to state argument. \n\nThis method is intended to be extended by the user with the above signature, specifying the type of model.\n\n\n\n\n\n","category":"function"},{"location":"#ParticleDA.update_state_deterministic!","page":"ParticleDA.jl","title":"ParticleDA.update_state_deterministic!","text":"ParticleDA.update_state_deterministic!(state, model, time_index)\n\nApply the deterministic component of the state time update at discrete time index  time_index for the model described by model for the state vector state writing the updated state back to the state argument.\n\nThis method is intended to be extended by the user with the above signature, specifying the type of model.\n\n\n\n\n\n","category":"function"},{"location":"#ParticleDA.update_state_stochastic!","page":"ParticleDA.jl","title":"ParticleDA.update_state_stochastic!","text":"ParticleDA.update_state_stochastic!(state, model, rng)\n\nApply the stochastic component of the state time update for the model described by model for the state vector state, using random number generator rng to generate random draws and writing the updated state back to the state argument.\n\nThis method is intended to be extended by the user with the above signature, specifying the type of model.\n\n\n\n\n\n","category":"function"},{"location":"#ParticleDA.sample_observation_given_state!","page":"ParticleDA.jl","title":"ParticleDA.sample_observation_given_state!","text":"ParticleDA.sample_observation_given_state!(observation, state, model, rng)\n\nSimulate noisy observations of the state state of model described by model and write to observation array using rng to generate any random draws.\n\nThis method is intended to be extended by the user with the above signature, specifying the type of model.\n\n\n\n\n\n","category":"function"},{"location":"#ParticleDA.get_log_density_observation_given_state","page":"ParticleDA.jl","title":"ParticleDA.get_log_density_observation_given_state","text":"ParticleDA.get_log_density_observation_given_state(\n    observation, state, model\n) -> Real\n\nReturn the logarithm of the probability density of an observation vector observation given a state vector state for the model associated with model. Any additive  terms that are constant with respect to the state may be neglected.\n\nThis method is intended to be extended by the user with the above signature, specifying the type of model.\n\n\n\n\n\n","category":"function"},{"location":"#ParticleDA.write_model_metadata","page":"ParticleDA.jl","title":"ParticleDA.write_model_metadata","text":"ParticleDA.write_model_metadata(file::HDF5.File, model)\n\nWrite metadata for with the model described by model to the HDF5 file file.\n\nThis method is intended to be extended by the user with the above signature, specifying the type of model.\n\n\n\n\n\n","category":"function"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"Optionally, if the model has additive Gaussian observation and state noise, it may also extend the following methods, again using the model type for dispatch, to allow using the more statistically efficient OptimalFilter for filtering","category":"page"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"ParticleDA.get_observation_mean_given_state!\nParticleDA.get_covariance_state_noise\nParticleDA.get_covariance_observation_noise\nParticleDA.get_covariance_state_observation_given_previous_state\nParticleDA.get_covariance_observation_observation_given_previous_state","category":"page"},{"location":"#ParticleDA.get_observation_mean_given_state!","page":"ParticleDA.jl","title":"ParticleDA.get_observation_mean_given_state!","text":"ParticleDA.get_observation_mean_given_state!(observation_mean, state, model)\n\nCompute the mean of the multivariate normal distribution on the observations given the current state and write to the first argument.\n\nThis method is intended to be extended by the user with the above signature, specifying the type of model. Only required for filtering conditionally Gaussian models with  the optimal proposal filter implementation in OptimalFilter.\n\n\n\n\n\n","category":"function"},{"location":"#ParticleDA.get_covariance_state_noise","page":"ParticleDA.jl","title":"ParticleDA.get_covariance_state_noise","text":"ParticleDA.get_covariance_state_noise(model, i, j) -> Real\n\nReturn covariance cov(U[i], U[j]) between components of the zero-mean Gaussian state  noise vector U.\n\nThis method is intended to be extended by the user with the above signature, specifying the type of model. Only required for filtering conditionally Gaussian models with  the optimal proposal filter implementation in OptimalFilter.\n\n\n\n\n\n","category":"function"},{"location":"#ParticleDA.get_covariance_observation_noise","page":"ParticleDA.jl","title":"ParticleDA.get_covariance_observation_noise","text":"ParticleDA.get_covariance_observation_noise(model, i, j) -> Real\n\nReturn covariance cov(V[i], V[j]) between components of the zero-mean Gaussian  observation noise vector V.\n\nThis method is intended to be extended by the user with the above signature, specifying the type of model. Only required for filtering conditionally Gaussian models with  the optimal proposal filter implementation in OptimalFilter.\n\n\n\n\n\n","category":"function"},{"location":"#ParticleDA.get_covariance_state_observation_given_previous_state","page":"ParticleDA.jl","title":"ParticleDA.get_covariance_state_observation_given_previous_state","text":"ParticleDA.get_covariance_state_observation_given_previous_state(\n    model, i, j\n) -> Real\n\nReturn the covariance cov(X[i], Y[j]) between components of the state vector  X = F(x) + U and observation vector Y = H * X + V where H is the linear  observation operator, F the (potentially non-linear) forward operator describing the  deterministic state dynamics, U is a zero-mean Gaussian state noise vector, V is a  zero-mean Gaussian observation noise vector and x is the state at the previous  observation time.\n\nThis method is intended to be extended by the user with the above signature, specifying the type of model. Only required for filtering conditionally Gaussian models with  the optimal proposal filter implementation in OptimalFilter.\n\n\n\n\n\n","category":"function"},{"location":"#ParticleDA.get_covariance_observation_observation_given_previous_state","page":"ParticleDA.jl","title":"ParticleDA.get_covariance_observation_observation_given_previous_state","text":"ParticleDA.get_covariance_observation_observation_given_previous_state(\n    model, i, j\n) -> Real\n\nReturn covariance cov(Y[i], Y[j]) between components of the observation vector  Y = H * (F(x) + U) + V where H is the linear observation operator, F the  (potentially non-linear) forward operator describing the deterministic state dynamics, U is a zero-mean Gaussian state noise vector, V is a zero-mean Gaussian observation noise vector and x is the state at the previous observation time.\n\nThis method is intended to be extended by the user with the above signature, specifying the type of model. Only required for filtering conditionally Gaussian models with  the optimal proposal filter implementation in OptimalFilter.\n\n\n\n\n\n","category":"function"},{"location":"#Input-parameters","page":"ParticleDA.jl","title":"Input parameters","text":"","category":"section"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"You can store the input parameters in an YAML file with the following structure","category":"page"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"filter:\n  key1: value1\n\nmodel:\n  model_name1:\n    key2: value2\n    key3: value3\n  model_name2:\n    key4: value4\n    key5: value5","category":"page"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"The parameters under filter are related to the particle filter, under model you can specify the parameters for different models.","category":"page"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"The particle filter parameters are saved in the following data structure:","category":"page"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"ParticleDA.FilterParameters","category":"page"},{"location":"#ParticleDA.FilterParameters","page":"ParticleDA.jl","title":"ParticleDA.FilterParameters","text":"FilterParameters()\n\nParameters for ParticleDA run. Keyword arguments:\n\nmaster_rank : Id of MPI rank that performs serial computations\nverbose::Bool : Flag to control whether to write output\noutput_filename::String : Name of output file\nnprt::Int : Number of particles for particle filter\nenable_timers::Bool : Flag to control run time measurements\nparticle_save_time_indices: Set of time indices to save particles at\nseed: Seed to initialise state of random number generator used for filtering\n\n\n\n\n\n","category":"type"},{"location":"#Example:-estimating-the-state-in-a-tsunami-model","page":"ParticleDA.jl","title":"Example: estimating the state in a tsunami model","text":"","category":"section"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"A full example of a model interfacing ParticleDA is available in test/models/llw2d.jl.  This model represents a simple two dimensional simulation of tsunami dynamics and is  partly based on the tsunami data assimilation code by  Takuto Maeda. The particle filter can be run with observations simulated from the model as follows","category":"page"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"# Load ParticleDA\nusing ParticleDA\n\n# Save some variables for later use\ntest_dir = joinpath(dirname(pathof(ParticleDA)), \"..\", \"test\")\nllw2d_src = joinpath(test_dir, \"models\", \"llw2d.jl\")\ninput_file = joinpath(test_dir, \"integration_test_1.yaml\")\nobservation_file = tempname()\n\n# Instantiate the test environment\nusing Pkg\nPkg.activate(test_dir)\nPkg.instantiate()\n\n# Include the sample model source code and load it\ninclude(llw2d_src)\nusing .LLW2d\n\n# Simulate observations from the model to use \nsimulate_observations_from_model(LLW2d.init, input_file, observation_file)\n\n# Run the (optimal proposal) particle filter with simulated observations computing the\n# mean and variance of the particle ensemble. On non-Intel architectures you may need\n# to use NaiveMeanAndVarSummaryStat instead\nfinal_states, final_statistics = run_particle_filter(\n  LLW2d.init, input_file, observation_file, OptimalFilter, MeanAndVarSummaryStat\n)","category":"page"},{"location":"#Parameters-of-the-test-model","page":"ParticleDA.jl","title":"Parameters of the test model","text":"","category":"section"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"The Input parameters section shows how to pass the input parameters for the filter and the model.  For the model included in the test suite, called llw2d, you can set the following parameters:","category":"page"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"LLW2d.LLW2dModelParameters","category":"page"},{"location":"#Main.LLW2d.LLW2dModelParameters","page":"ParticleDA.jl","title":"Main.LLW2d.LLW2dModelParameters","text":"LLW2dModelParameters()\n\nParameters for the linear long wave two-dimensional (LLW2d) model. Keyword arguments:\n\nnx::Int : Number of grid points in the x direction\nny::Int : Number of grid points in the y direction\nx_length::AbstractFloat : Domain size in metres in the x direction\ny_length::AbstractFloat : Domain size in metres in the y direction\ndx::AbstractFloat : Distance in metres between grid points in the x direction\ndy::AbstractFloat : Distance in metrtes between grid points in the y direction\nstation_filename::String : Name of input file for station coordinates\nn_stations_x::Int : Number of observation stations in the x direction (if using regular grid)\nn_stations_y::Int : Number of observation stations in the y direction (if using regular grid)\nstation_distance_x::Float : Distance in metres between stations in the x direction (if using regular grid)\nstation_distance_y::Float : Distance in metres between stations in the y direction (if using regular grid)\nstation_boundary_x::Float : Distance in metres between bottom left edge of box and first station in the x direction (if using regular grid)\nstation_boundary_y::Float : Distance in metres between bottom left edge of box and first station in the y direction (if using regular grid)\nn_integration_step::Int : Number of sub-steps to integrate the forward model per time step\ntime_step::AbstractFloat : Time step length in seconds\npeak_position::Vector{AbstractFloat} : The `[x, y] coordinates in metres of the initial wave peak\npeak_height::AbstractFloat : The height in metres of the initial wave peak\nsource_size::AbstractFloat : Cutoff distance in metres from the peak for the initial wave\nbathymetry_setup::AbstractFloat : Bathymetry set-up\nlambda::AbstractFloat : Length scale for Matérn covariance kernel in background noise\nnu::AbstractFloat : Smoothess parameter for Matérn covariance kernel in background noise\nsigma::AbstractFloat : Marginal standard deviation for Matérn covariance kernel in background noise\nlambda_initial_state::AbstractFloat : Length scale for Matérn covariance kernel in initial state of particles\nnu_initial_state::AbstractFloat : Smoothess parameter for Matérn covariance kernel in initial state of particles\nsigma_initial_state::AbstractFloat : Marginal standard deviation for Matérn covariance kernel in initial state of particles\npadding::Int : Min padding for circulant embedding gaussian random field generator\nprimes::Int: Whether the size of the minimum circulant embedding of the covariance matrix can be written as a product of small primes (2, 3, 5 and 7). Default is true.\nuse_peak_initial_state_mean::Bool: Whether to set mean of initial height field to a wave peak (true) or to all zeros (false).  In both cases the initial mean of the other state variables is zero.\nabsorber_thickness_fraction::Float : Thickness of absorber for sponge absorbing boundary conditions, fraction of grid size\nboundary_damping::Float : Damping for boundaries\ncutoff_depth::Float : Shallowest water depth\nobs_noise_std::Vector: Standard deviations of noise added to observations of the true state\nobserved_state_var_indices::Vector: Vector containing the indices of the observed state variables (1: height, 2: velocity x-component, 3: velocity y-component)\n\n\n\n\n\n","category":"type"},{"location":"#Observation-station-coordinates","page":"ParticleDA.jl","title":"Observation station coordinates","text":"","category":"section"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"The coordinates of the observation stations can be set in two different ways.","category":"page"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"Provide the coordinates in an input file. Set the parameter station_filename to the name of your input file. The input file is in plain text, the format is one row per station containing x, y - coordinates in metres. Here is a simple example with two stations\n# Comment lines starting with '#' will be ignored by the code\n# This file contains two stations: at [1km, 1km] and [2km, 2km]\n1.0e3, 1.0e3\n2.0e3, 2.0e3\nProvide parameters for an equispaced rectilinear grid of observation stations. The values of these parameters should then be set:\nn_stations_x : Number of observation stations in the x direction\nn_stations_y : Number of observation stations in the y direction\nstation_distance_x : Distance between stations in the x direction (m)\nstation_distance_y : Distance between stations in the y direction (m)\nstation_boundary_x : Distance between bottom left edge of box and first station in the x direction (m)\nstation_boundary_y : Distance between bottom left edge of box and first station in the y direction (m)\nAs an example, one could set\nn_stations_x=2,\nn_stations_y=2,\nstation_distance_x=1.0e3,\nstation_distance_y=1.0e3,\nstation_boundary_x=10.0e3,\nstation_boundary_y=10.0e3,\nto generate 4 stations at [10km, 10km], [10km, 11km], [11km, 10km] and [11km, 11km].","category":"page"},{"location":"#Output","page":"ParticleDA.jl","title":"Output","text":"","category":"section"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"If the filter parameter verbose is set to true, run_particle_filter will produce an HDF5 file in the run directory. The file name is particle_da.h5 by default (this is configurable using the output_filename filter parameter). The file contains the summary statistics of the estimate state distribution (by default the mean and variance), particle weights, parameters used, and other metadata at each time step observation were assimilated. To read the output file, use the HDF5 library.","category":"page"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"A basic plotting tool is provided in a Jupyter notebook. This is intended as a template to build more sophisticated postprocessing tools, but can be used for some simple analysis. Set the variable timestamp in the third cell to plot different time slices from the output file. More functionality may be added as the package develops.","category":"page"},{"location":"#Running-in-parallel","page":"ParticleDA.jl","title":"Running in parallel","text":"","category":"section"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"The particle state update is parallelised using both MPI and threading. According to our preliminary tests both methods work well at small scale. To use the threading, set the environment variable JULIA_NUM_THREADS to the number of threads you want to use before starting Julia and then call the run_particle_filter function normally. You can check the number of threads julia has available by calling in Julia's REPL","category":"page"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"Threads.nthreads()","category":"page"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"To use the MPI parallelisation, write a Julia script that calls the run_particle_filter function for the relevant model and observations and run it in an Unix shell with","category":"page"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"mpirun -np <your_number_of_processes> julia <your_julia_script>","category":"page"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"Note that the parallel performance may vary depending on the performance of the algorithm. In general, a degeneracy of the particle weights will lead to poor load balance and parallel performance. See this issue for more details.","category":"page"},{"location":"#Testing","page":"ParticleDA.jl","title":"Testing","text":"","category":"section"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"We have a basic test suite for ParticleDA.jl.  You can run the tests by entering the package manager mode in Julia's REPL with ] and running the command","category":"page"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"test ParticleDA","category":"page"},{"location":"#License","page":"ParticleDA.jl","title":"License","text":"","category":"section"},{"location":"","page":"ParticleDA.jl","title":"ParticleDA.jl","text":"The ParticleDA.jl package is licensed under the MIT \"Expat\" License.","category":"page"}]
}
